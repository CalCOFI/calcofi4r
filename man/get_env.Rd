% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{get_env}
\alias{get_env}
\title{Retrieve Environmental Data from Database}
\usage{
get_env(env_var, qtr, date_range, min_depth, max_depth)
}
\arguments{
\item{env_var}{Character string of database column name for environmental variable (e.g., "t_deg_c", "salnty")}

\item{qtr}{Character or numeric vector of quarters to include (1-4)}

\item{date_range}{Date vector of length 2 (start date, end date)}

\item{min_depth}{Numeric minimum depth in meters}

\item{max_depth}{Numeric maximum depth in meters}
}
\value{
dbplyr lazy table with columns:
\itemize{
\item \code{date} - date of cast
\item \code{time} - time of cast (seconds since midnight)
\item \code{dtime} - datetime (computed via SQL CAST and INTERVAL)
\item \code{depthm} - depth in meters
\item \code{lat_dec} - latitude (decimal degrees)
\item \code{lon_dec} - longitude (decimal degrees)
\item \code{qty} - renamed environmental variable value
\item \code{hex_h3res*} - H3 hexagon indices at multiple resolutions
}
}
\description{
Queries environmental bottle cast data with temporal, depth, and variable filters.
Returns a dbplyr lazy table for efficient downstream processing.
}
\details{
The function joins \code{cast} and \code{bottle} tables, then joins with
\code{site} to obtain H3 spatial indices. Only records with non-NA values
for the selected variable are returned. Datetime is constructed from separate
date and time fields using DuckDB SQL.
}
\examples{
\dontrun{
# retrieve temperature data for Q1-Q2 2010-2020
df_env <- get_env(
  env_var    = "t_deg_c",
  qtr        = c(1, 2),
  date_range = as.Date(c("2010-01-01", "2020-12-31")),
  min_depth  = 0,
  max_depth  = 100
)
df_env |> collect()
}

}
\seealso{
\code{\link{prep_env_hex}} for spatial aggregation

\code{\link{prep_ts_env}} for temporal aggregation
}
\concept{read}
